// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/xtruder/pdf-clipper/packages/server-go/graph/model"
	"github.com/xtruder/pdf-clipper/packages/server-go/internal/util"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	AccountInfo struct {
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	AccountInfoUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	AccountUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	BlobInfo struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		Hash      func(childComplexity int) int
		Local     func(childComplexity int) int
		MimeType  func(childComplexity int) int
		Size      func(childComplexity int) int
		Source    func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	BlobInfoUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	Document struct {
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		FileHash  func(childComplexity int) int
		ID        func(childComplexity int) int
		Local     func(childComplexity int) int
		Meta      func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	DocumentHighlight struct {
		Content      func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		DocumentID   func(childComplexity int) int
		DocumentType func(childComplexity int) int
		ID           func(childComplexity int) int
		ImageHash    func(childComplexity int) int
		Local        func(childComplexity int) int
		Location     func(childComplexity int) int
		Sequence     func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	DocumentHighlightUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	DocumentMember struct {
		AcceptedAt func(childComplexity int) int
		AccountID  func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		CreatedBy  func(childComplexity int) int
		DeletedAt  func(childComplexity int) int
		DocumentID func(childComplexity int) int
		ID         func(childComplexity int) int
		Local      func(childComplexity int) int
		Role       func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	DocumentMemberUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	DocumentUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	Mutation struct {
		PushAccountChanges           func(childComplexity int, input []model.AccountInput) int
		PushAccountInfoChanges       func(childComplexity int, input []model.AccountInfoInput) int
		PushBlobInfoChanges          func(childComplexity int, input []model.BlobInfoInput) int
		PushDocumentChanges          func(childComplexity int, input []model.DocumentInput) int
		PushDocumentHighlightChanges func(childComplexity int, input []model.DocumentHighlightInput) int
		PushDocumentMemberChanges    func(childComplexity int, input []model.DocumentMemberInput) int
		PushSessionChanges           func(childComplexity int, input []model.SessionInput) int
	}

	Query struct {
		GetAccountChanges           func(childComplexity int, since time.Time, limit *int) int
		GetAccountInfoChanges       func(childComplexity int, since time.Time, limit *int) int
		GetBlobInfoChanges          func(childComplexity int, since time.Time, limit *int) int
		GetDocumentChanges          func(childComplexity int, since time.Time, limit *int) int
		GetDocumentHighlightChanges func(childComplexity int, since time.Time, limit *int) int
		GetDocumentMemberChanges    func(childComplexity int, since time.Time, limit *int) int
		GetSessionChanges           func(childComplexity int, since time.Time, limit *int) int
	}

	Session struct {
		AccountID     func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		SyncDocuments func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	SessionUpdateResult struct {
		Errors   func(childComplexity int) int
		Rejected func(childComplexity int) int
		Updated  func(childComplexity int) int
	}

	Subscription struct {
		SyncAccountInfoUpdates       func(childComplexity int) int
		SyncAccountUpdates           func(childComplexity int) int
		SyncBlobInfoUpdates          func(childComplexity int) int
		SyncDocumentHighlightUpdates func(childComplexity int) int
		SyncDocumentMemberUpdates    func(childComplexity int) int
		SyncDocumentUpdates          func(childComplexity int) int
		SyncSessionUpdates           func(childComplexity int) int
	}

	UpdateError struct {
		Error func(childComplexity int) int
		ID    func(childComplexity int) int
	}
}

type MutationResolver interface {
	PushAccountChanges(ctx context.Context, input []model.AccountInput) (*model.AccountUpdateResult, error)
	PushAccountInfoChanges(ctx context.Context, input []model.AccountInfoInput) (*model.AccountInfoUpdateResult, error)
	PushSessionChanges(ctx context.Context, input []model.SessionInput) (*model.SessionUpdateResult, error)
	PushDocumentChanges(ctx context.Context, input []model.DocumentInput) (*model.DocumentUpdateResult, error)
	PushDocumentMemberChanges(ctx context.Context, input []model.DocumentMemberInput) (*model.DocumentMemberUpdateResult, error)
	PushDocumentHighlightChanges(ctx context.Context, input []model.DocumentHighlightInput) (*model.DocumentHighlightUpdateResult, error)
	PushBlobInfoChanges(ctx context.Context, input []model.BlobInfoInput) (*model.BlobInfoUpdateResult, error)
}
type QueryResolver interface {
	GetAccountChanges(ctx context.Context, since time.Time, limit *int) ([]model.Account, error)
	GetAccountInfoChanges(ctx context.Context, since time.Time, limit *int) ([]model.AccountInfo, error)
	GetSessionChanges(ctx context.Context, since time.Time, limit *int) ([]model.Session, error)
	GetDocumentChanges(ctx context.Context, since time.Time, limit *int) ([]model.Document, error)
	GetDocumentMemberChanges(ctx context.Context, since time.Time, limit *int) ([]model.DocumentMember, error)
	GetDocumentHighlightChanges(ctx context.Context, since time.Time, limit *int) ([]model.DocumentHighlight, error)
	GetBlobInfoChanges(ctx context.Context, since time.Time, limit *int) ([]model.BlobInfo, error)
}
type SubscriptionResolver interface {
	SyncAccountUpdates(ctx context.Context) (<-chan []model.Account, error)
	SyncAccountInfoUpdates(ctx context.Context) (<-chan []model.AccountInfo, error)
	SyncSessionUpdates(ctx context.Context) (<-chan []model.Session, error)
	SyncDocumentUpdates(ctx context.Context) (<-chan []model.Document, error)
	SyncDocumentMemberUpdates(ctx context.Context) (<-chan []model.DocumentMember, error)
	SyncDocumentHighlightUpdates(ctx context.Context) (<-chan []model.DocumentHighlight, error)
	SyncBlobInfoUpdates(ctx context.Context) (<-chan []model.BlobInfo, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.createdAt":
		if e.complexity.Account.CreatedAt == nil {
			break
		}

		return e.complexity.Account.CreatedAt(childComplexity), true

	case "Account.deletedAt":
		if e.complexity.Account.DeletedAt == nil {
			break
		}

		return e.complexity.Account.DeletedAt(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.name":
		if e.complexity.Account.Name == nil {
			break
		}

		return e.complexity.Account.Name(childComplexity), true

	case "Account.updatedAt":
		if e.complexity.Account.UpdatedAt == nil {
			break
		}

		return e.complexity.Account.UpdatedAt(childComplexity), true

	case "AccountInfo.id":
		if e.complexity.AccountInfo.ID == nil {
			break
		}

		return e.complexity.AccountInfo.ID(childComplexity), true

	case "AccountInfo.name":
		if e.complexity.AccountInfo.Name == nil {
			break
		}

		return e.complexity.AccountInfo.Name(childComplexity), true

	case "AccountInfo.updatedAt":
		if e.complexity.AccountInfo.UpdatedAt == nil {
			break
		}

		return e.complexity.AccountInfo.UpdatedAt(childComplexity), true

	case "AccountInfoUpdateResult.errors":
		if e.complexity.AccountInfoUpdateResult.Errors == nil {
			break
		}

		return e.complexity.AccountInfoUpdateResult.Errors(childComplexity), true

	case "AccountInfoUpdateResult.rejected":
		if e.complexity.AccountInfoUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.AccountInfoUpdateResult.Rejected(childComplexity), true

	case "AccountInfoUpdateResult.updated":
		if e.complexity.AccountInfoUpdateResult.Updated == nil {
			break
		}

		return e.complexity.AccountInfoUpdateResult.Updated(childComplexity), true

	case "AccountUpdateResult.errors":
		if e.complexity.AccountUpdateResult.Errors == nil {
			break
		}

		return e.complexity.AccountUpdateResult.Errors(childComplexity), true

	case "AccountUpdateResult.rejected":
		if e.complexity.AccountUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.AccountUpdateResult.Rejected(childComplexity), true

	case "AccountUpdateResult.updated":
		if e.complexity.AccountUpdateResult.Updated == nil {
			break
		}

		return e.complexity.AccountUpdateResult.Updated(childComplexity), true

	case "BlobInfo.createdAt":
		if e.complexity.BlobInfo.CreatedAt == nil {
			break
		}

		return e.complexity.BlobInfo.CreatedAt(childComplexity), true

	case "BlobInfo.createdBy":
		if e.complexity.BlobInfo.CreatedBy == nil {
			break
		}

		return e.complexity.BlobInfo.CreatedBy(childComplexity), true

	case "BlobInfo.hash":
		if e.complexity.BlobInfo.Hash == nil {
			break
		}

		return e.complexity.BlobInfo.Hash(childComplexity), true

	case "BlobInfo.local":
		if e.complexity.BlobInfo.Local == nil {
			break
		}

		return e.complexity.BlobInfo.Local(childComplexity), true

	case "BlobInfo.mimeType":
		if e.complexity.BlobInfo.MimeType == nil {
			break
		}

		return e.complexity.BlobInfo.MimeType(childComplexity), true

	case "BlobInfo.size":
		if e.complexity.BlobInfo.Size == nil {
			break
		}

		return e.complexity.BlobInfo.Size(childComplexity), true

	case "BlobInfo.source":
		if e.complexity.BlobInfo.Source == nil {
			break
		}

		return e.complexity.BlobInfo.Source(childComplexity), true

	case "BlobInfo.type":
		if e.complexity.BlobInfo.Type == nil {
			break
		}

		return e.complexity.BlobInfo.Type(childComplexity), true

	case "BlobInfo.updatedAt":
		if e.complexity.BlobInfo.UpdatedAt == nil {
			break
		}

		return e.complexity.BlobInfo.UpdatedAt(childComplexity), true

	case "BlobInfoUpdateResult.errors":
		if e.complexity.BlobInfoUpdateResult.Errors == nil {
			break
		}

		return e.complexity.BlobInfoUpdateResult.Errors(childComplexity), true

	case "BlobInfoUpdateResult.rejected":
		if e.complexity.BlobInfoUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.BlobInfoUpdateResult.Rejected(childComplexity), true

	case "BlobInfoUpdateResult.updated":
		if e.complexity.BlobInfoUpdateResult.Updated == nil {
			break
		}

		return e.complexity.BlobInfoUpdateResult.Updated(childComplexity), true

	case "Document.createdAt":
		if e.complexity.Document.CreatedAt == nil {
			break
		}

		return e.complexity.Document.CreatedAt(childComplexity), true

	case "Document.createdBy":
		if e.complexity.Document.CreatedBy == nil {
			break
		}

		return e.complexity.Document.CreatedBy(childComplexity), true

	case "Document.deletedAt":
		if e.complexity.Document.DeletedAt == nil {
			break
		}

		return e.complexity.Document.DeletedAt(childComplexity), true

	case "Document.fileHash":
		if e.complexity.Document.FileHash == nil {
			break
		}

		return e.complexity.Document.FileHash(childComplexity), true

	case "Document.id":
		if e.complexity.Document.ID == nil {
			break
		}

		return e.complexity.Document.ID(childComplexity), true

	case "Document.local":
		if e.complexity.Document.Local == nil {
			break
		}

		return e.complexity.Document.Local(childComplexity), true

	case "Document.meta":
		if e.complexity.Document.Meta == nil {
			break
		}

		return e.complexity.Document.Meta(childComplexity), true

	case "Document.type":
		if e.complexity.Document.Type == nil {
			break
		}

		return e.complexity.Document.Type(childComplexity), true

	case "Document.updatedAt":
		if e.complexity.Document.UpdatedAt == nil {
			break
		}

		return e.complexity.Document.UpdatedAt(childComplexity), true

	case "DocumentHighlight.content":
		if e.complexity.DocumentHighlight.Content == nil {
			break
		}

		return e.complexity.DocumentHighlight.Content(childComplexity), true

	case "DocumentHighlight.createdAt":
		if e.complexity.DocumentHighlight.CreatedAt == nil {
			break
		}

		return e.complexity.DocumentHighlight.CreatedAt(childComplexity), true

	case "DocumentHighlight.createdBy":
		if e.complexity.DocumentHighlight.CreatedBy == nil {
			break
		}

		return e.complexity.DocumentHighlight.CreatedBy(childComplexity), true

	case "DocumentHighlight.deletedAt":
		if e.complexity.DocumentHighlight.DeletedAt == nil {
			break
		}

		return e.complexity.DocumentHighlight.DeletedAt(childComplexity), true

	case "DocumentHighlight.documentId":
		if e.complexity.DocumentHighlight.DocumentID == nil {
			break
		}

		return e.complexity.DocumentHighlight.DocumentID(childComplexity), true

	case "DocumentHighlight.documentType":
		if e.complexity.DocumentHighlight.DocumentType == nil {
			break
		}

		return e.complexity.DocumentHighlight.DocumentType(childComplexity), true

	case "DocumentHighlight.id":
		if e.complexity.DocumentHighlight.ID == nil {
			break
		}

		return e.complexity.DocumentHighlight.ID(childComplexity), true

	case "DocumentHighlight.imageHash":
		if e.complexity.DocumentHighlight.ImageHash == nil {
			break
		}

		return e.complexity.DocumentHighlight.ImageHash(childComplexity), true

	case "DocumentHighlight.local":
		if e.complexity.DocumentHighlight.Local == nil {
			break
		}

		return e.complexity.DocumentHighlight.Local(childComplexity), true

	case "DocumentHighlight.location":
		if e.complexity.DocumentHighlight.Location == nil {
			break
		}

		return e.complexity.DocumentHighlight.Location(childComplexity), true

	case "DocumentHighlight.sequence":
		if e.complexity.DocumentHighlight.Sequence == nil {
			break
		}

		return e.complexity.DocumentHighlight.Sequence(childComplexity), true

	case "DocumentHighlight.updatedAt":
		if e.complexity.DocumentHighlight.UpdatedAt == nil {
			break
		}

		return e.complexity.DocumentHighlight.UpdatedAt(childComplexity), true

	case "DocumentHighlightUpdateResult.errors":
		if e.complexity.DocumentHighlightUpdateResult.Errors == nil {
			break
		}

		return e.complexity.DocumentHighlightUpdateResult.Errors(childComplexity), true

	case "DocumentHighlightUpdateResult.rejected":
		if e.complexity.DocumentHighlightUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.DocumentHighlightUpdateResult.Rejected(childComplexity), true

	case "DocumentHighlightUpdateResult.updated":
		if e.complexity.DocumentHighlightUpdateResult.Updated == nil {
			break
		}

		return e.complexity.DocumentHighlightUpdateResult.Updated(childComplexity), true

	case "DocumentMember.acceptedAt":
		if e.complexity.DocumentMember.AcceptedAt == nil {
			break
		}

		return e.complexity.DocumentMember.AcceptedAt(childComplexity), true

	case "DocumentMember.accountId":
		if e.complexity.DocumentMember.AccountID == nil {
			break
		}

		return e.complexity.DocumentMember.AccountID(childComplexity), true

	case "DocumentMember.createdAt":
		if e.complexity.DocumentMember.CreatedAt == nil {
			break
		}

		return e.complexity.DocumentMember.CreatedAt(childComplexity), true

	case "DocumentMember.createdBy":
		if e.complexity.DocumentMember.CreatedBy == nil {
			break
		}

		return e.complexity.DocumentMember.CreatedBy(childComplexity), true

	case "DocumentMember.deletedAt":
		if e.complexity.DocumentMember.DeletedAt == nil {
			break
		}

		return e.complexity.DocumentMember.DeletedAt(childComplexity), true

	case "DocumentMember.documentId":
		if e.complexity.DocumentMember.DocumentID == nil {
			break
		}

		return e.complexity.DocumentMember.DocumentID(childComplexity), true

	case "DocumentMember.id":
		if e.complexity.DocumentMember.ID == nil {
			break
		}

		return e.complexity.DocumentMember.ID(childComplexity), true

	case "DocumentMember.local":
		if e.complexity.DocumentMember.Local == nil {
			break
		}

		return e.complexity.DocumentMember.Local(childComplexity), true

	case "DocumentMember.role":
		if e.complexity.DocumentMember.Role == nil {
			break
		}

		return e.complexity.DocumentMember.Role(childComplexity), true

	case "DocumentMember.updatedAt":
		if e.complexity.DocumentMember.UpdatedAt == nil {
			break
		}

		return e.complexity.DocumentMember.UpdatedAt(childComplexity), true

	case "DocumentMemberUpdateResult.errors":
		if e.complexity.DocumentMemberUpdateResult.Errors == nil {
			break
		}

		return e.complexity.DocumentMemberUpdateResult.Errors(childComplexity), true

	case "DocumentMemberUpdateResult.rejected":
		if e.complexity.DocumentMemberUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.DocumentMemberUpdateResult.Rejected(childComplexity), true

	case "DocumentMemberUpdateResult.updated":
		if e.complexity.DocumentMemberUpdateResult.Updated == nil {
			break
		}

		return e.complexity.DocumentMemberUpdateResult.Updated(childComplexity), true

	case "DocumentUpdateResult.errors":
		if e.complexity.DocumentUpdateResult.Errors == nil {
			break
		}

		return e.complexity.DocumentUpdateResult.Errors(childComplexity), true

	case "DocumentUpdateResult.rejected":
		if e.complexity.DocumentUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.DocumentUpdateResult.Rejected(childComplexity), true

	case "DocumentUpdateResult.updated":
		if e.complexity.DocumentUpdateResult.Updated == nil {
			break
		}

		return e.complexity.DocumentUpdateResult.Updated(childComplexity), true

	case "Mutation.pushAccountChanges":
		if e.complexity.Mutation.PushAccountChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushAccountChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushAccountChanges(childComplexity, args["input"].([]model.AccountInput)), true

	case "Mutation.pushAccountInfoChanges":
		if e.complexity.Mutation.PushAccountInfoChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushAccountInfoChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushAccountInfoChanges(childComplexity, args["input"].([]model.AccountInfoInput)), true

	case "Mutation.pushBlobInfoChanges":
		if e.complexity.Mutation.PushBlobInfoChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushBlobInfoChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushBlobInfoChanges(childComplexity, args["input"].([]model.BlobInfoInput)), true

	case "Mutation.pushDocumentChanges":
		if e.complexity.Mutation.PushDocumentChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushDocumentChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushDocumentChanges(childComplexity, args["input"].([]model.DocumentInput)), true

	case "Mutation.pushDocumentHighlightChanges":
		if e.complexity.Mutation.PushDocumentHighlightChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushDocumentHighlightChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushDocumentHighlightChanges(childComplexity, args["input"].([]model.DocumentHighlightInput)), true

	case "Mutation.pushDocumentMemberChanges":
		if e.complexity.Mutation.PushDocumentMemberChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushDocumentMemberChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushDocumentMemberChanges(childComplexity, args["input"].([]model.DocumentMemberInput)), true

	case "Mutation.pushSessionChanges":
		if e.complexity.Mutation.PushSessionChanges == nil {
			break
		}

		args, err := ec.field_Mutation_pushSessionChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PushSessionChanges(childComplexity, args["input"].([]model.SessionInput)), true

	case "Query.getAccountChanges":
		if e.complexity.Query.GetAccountChanges == nil {
			break
		}

		args, err := ec.field_Query_getAccountChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAccountChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getAccountInfoChanges":
		if e.complexity.Query.GetAccountInfoChanges == nil {
			break
		}

		args, err := ec.field_Query_getAccountInfoChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAccountInfoChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getBlobInfoChanges":
		if e.complexity.Query.GetBlobInfoChanges == nil {
			break
		}

		args, err := ec.field_Query_getBlobInfoChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBlobInfoChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getDocumentChanges":
		if e.complexity.Query.GetDocumentChanges == nil {
			break
		}

		args, err := ec.field_Query_getDocumentChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDocumentChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getDocumentHighlightChanges":
		if e.complexity.Query.GetDocumentHighlightChanges == nil {
			break
		}

		args, err := ec.field_Query_getDocumentHighlightChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDocumentHighlightChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getDocumentMemberChanges":
		if e.complexity.Query.GetDocumentMemberChanges == nil {
			break
		}

		args, err := ec.field_Query_getDocumentMemberChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDocumentMemberChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Query.getSessionChanges":
		if e.complexity.Query.GetSessionChanges == nil {
			break
		}

		args, err := ec.field_Query_getSessionChanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSessionChanges(childComplexity, args["since"].(time.Time), args["limit"].(*int)), true

	case "Session.accountId":
		if e.complexity.Session.AccountID == nil {
			break
		}

		return e.complexity.Session.AccountID(childComplexity), true

	case "Session.createdAt":
		if e.complexity.Session.CreatedAt == nil {
			break
		}

		return e.complexity.Session.CreatedAt(childComplexity), true

	case "Session.deletedAt":
		if e.complexity.Session.DeletedAt == nil {
			break
		}

		return e.complexity.Session.DeletedAt(childComplexity), true

	case "Session.id":
		if e.complexity.Session.ID == nil {
			break
		}

		return e.complexity.Session.ID(childComplexity), true

	case "Session.syncDocuments":
		if e.complexity.Session.SyncDocuments == nil {
			break
		}

		return e.complexity.Session.SyncDocuments(childComplexity), true

	case "Session.updatedAt":
		if e.complexity.Session.UpdatedAt == nil {
			break
		}

		return e.complexity.Session.UpdatedAt(childComplexity), true

	case "SessionUpdateResult.errors":
		if e.complexity.SessionUpdateResult.Errors == nil {
			break
		}

		return e.complexity.SessionUpdateResult.Errors(childComplexity), true

	case "SessionUpdateResult.rejected":
		if e.complexity.SessionUpdateResult.Rejected == nil {
			break
		}

		return e.complexity.SessionUpdateResult.Rejected(childComplexity), true

	case "SessionUpdateResult.updated":
		if e.complexity.SessionUpdateResult.Updated == nil {
			break
		}

		return e.complexity.SessionUpdateResult.Updated(childComplexity), true

	case "Subscription.syncAccountInfoUpdates":
		if e.complexity.Subscription.SyncAccountInfoUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncAccountInfoUpdates(childComplexity), true

	case "Subscription.syncAccountUpdates":
		if e.complexity.Subscription.SyncAccountUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncAccountUpdates(childComplexity), true

	case "Subscription.syncBlobInfoUpdates":
		if e.complexity.Subscription.SyncBlobInfoUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncBlobInfoUpdates(childComplexity), true

	case "Subscription.syncDocumentHighlightUpdates":
		if e.complexity.Subscription.SyncDocumentHighlightUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncDocumentHighlightUpdates(childComplexity), true

	case "Subscription.syncDocumentMemberUpdates":
		if e.complexity.Subscription.SyncDocumentMemberUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncDocumentMemberUpdates(childComplexity), true

	case "Subscription.syncDocumentUpdates":
		if e.complexity.Subscription.SyncDocumentUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncDocumentUpdates(childComplexity), true

	case "Subscription.syncSessionUpdates":
		if e.complexity.Subscription.SyncSessionUpdates == nil {
			break
		}

		return e.complexity.Subscription.SyncSessionUpdates(childComplexity), true

	case "UpdateError.error":
		if e.complexity.UpdateError.Error == nil {
			break
		}

		return e.complexity.UpdateError.Error(childComplexity), true

	case "UpdateError.id":
		if e.complexity.UpdateError.ID == nil {
			break
		}

		return e.complexity.UpdateError.ID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountInfoInput,
		ec.unmarshalInputAccountInput,
		ec.unmarshalInputBlobInfoInput,
		ec.unmarshalInputDocumentHighlightInput,
		ec.unmarshalInputDocumentInput,
		ec.unmarshalInputDocumentMemberInput,
		ec.unmarshalInputSessionInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `type Query {
  getAccountChanges(since: DateTime!, limit: Int = 100): [Account!]!
  getAccountInfoChanges(since: DateTime!, limit: Int = 100): [AccountInfo!]!
  getSessionChanges(since: DateTime!, limit: Int = 100): [Session!]!
  getDocumentChanges(since: DateTime!, limit: Int = 100): [Document!]!
  getDocumentMemberChanges(since: DateTime!, limit: Int = 100): [DocumentMember!]!
  getDocumentHighlightChanges(since: DateTime!, limit: Int = 100): [DocumentHighlight!]!
  getBlobInfoChanges(since: DateTime!, limit: Int = 100): [BlobInfo!]!
}

"""schema for account"""
type Account {
  id: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
}

scalar UUID

scalar DateTime

"""schema for account"""
type AccountInfo {
  id: UUID!
  name: String
  updatedAt: DateTime
}

"""schema for session"""
type Session {
  id: UUID!
  accountId: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  syncDocuments: [String]
}

"""schema holding documents"""
type Document {
  id: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: UUID
  type: String!
  fileHash: String
  meta: JSON
  local: Boolean
}

scalar JSON

"""schema holding account documents"""
type DocumentMember {
  id: String
  documentId: UUID!
  accountId: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  acceptedAt: DateTime
  role: String!
  createdBy: UUID
  local: Boolean
}

"""schema for document highlights"""
type DocumentHighlight {
  id: UUID!
  documentId: UUID!
  documentType: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: UUID
  content: JSON
  location: JSON
  sequence: String!
  imageHash: String
  local: Boolean
}

"""schema for blobinfos collection"""
type BlobInfo {
  hash: String!
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UUID
  type: String!
  mimeType: String!
  size: Int!
  source: String!
  local: Boolean
}

type Mutation {
  pushAccountChanges(input: [AccountInput!]!): AccountUpdateResult!
  pushAccountInfoChanges(input: [AccountInfoInput!]!): AccountInfoUpdateResult!
  pushSessionChanges(input: [SessionInput!]!): SessionUpdateResult!
  pushDocumentChanges(input: [DocumentInput!]!): DocumentUpdateResult!
  pushDocumentMemberChanges(input: [DocumentMemberInput!]!): DocumentMemberUpdateResult!
  pushDocumentHighlightChanges(input: [DocumentHighlightInput!]!): DocumentHighlightUpdateResult!
  pushBlobInfoChanges(input: [BlobInfoInput!]!): BlobInfoUpdateResult!
}

type AccountUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [Account!]!

  """list of rejected documents, with current returned state"""
  rejected: [Account!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

type UpdateError {
  """Id of the resource that failed update"""
  id: String!

  """Error string associated with upd"""
  error: String
}

"""schema for account"""
input AccountInput {
  id: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
}

type AccountInfoUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [AccountInfo!]!

  """list of rejected documents, with current returned state"""
  rejected: [AccountInfo!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema for account"""
input AccountInfoInput {
  id: UUID!
  name: String
  updatedAt: DateTime
}

type SessionUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [Session!]!

  """list of rejected documents, with current returned state"""
  rejected: [Session!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema for session"""
input SessionInput {
  id: UUID!
  accountId: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  syncDocuments: [String]
}

type DocumentUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [Document!]!

  """list of rejected documents, with current returned state"""
  rejected: [Document!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema holding documents"""
input DocumentInput {
  id: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: UUID
  type: String!
  fileHash: String
  meta: JSON
  local: Boolean
}

type DocumentMemberUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [DocumentMember!]!

  """list of rejected documents, with current returned state"""
  rejected: [DocumentMember!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema holding account documents"""
input DocumentMemberInput {
  id: String
  documentId: UUID!
  accountId: UUID!
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  acceptedAt: DateTime
  role: String!
  createdBy: UUID
  local: Boolean
}

type DocumentHighlightUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [DocumentHighlight!]!

  """list of rejected documents, with current returned state"""
  rejected: [DocumentHighlight!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema for document highlights"""
input DocumentHighlightInput {
  id: UUID!
  documentId: UUID!
  documentType: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  createdBy: UUID
  content: JSON
  location: JSON
  sequence: String!
  imageHash: String
  local: Boolean
}

type BlobInfoUpdateResult {
  """list of updated documents that have been successfully processed"""
  updated: [BlobInfo!]!

  """list of rejected documents, with current returned state"""
  rejected: [BlobInfo!]!

  """List of errors associated with rejected documents"""
  errors: [UpdateError!]
}

"""schema for blobinfos collection"""
input BlobInfoInput {
  hash: String!
  createdAt: DateTime
  updatedAt: DateTime
  createdBy: UUID
  type: String!
  mimeType: String!
  size: Int!
  source: String!
  local: Boolean
}

type Subscription {
  syncAccountUpdates: [Account!]!
  syncAccountInfoUpdates: [AccountInfo!]!
  syncSessionUpdates: [Session!]!
  syncDocumentUpdates: [Document!]!
  syncDocumentMemberUpdates: [DocumentMember!]!
  syncDocumentHighlightUpdates: [DocumentHighlight!]!
  syncBlobInfoUpdates: [BlobInfo!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_pushAccountChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.AccountInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAccountInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushAccountInfoChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.AccountInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAccountInfoInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushBlobInfoChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.BlobInfoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNBlobInfoInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushDocumentChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.DocumentInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDocumentInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushDocumentHighlightChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.DocumentHighlightInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDocumentHighlightInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushDocumentMemberChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.DocumentMemberInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDocumentMemberInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pushSessionChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.SessionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSessionInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionInputᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAccountChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getAccountInfoChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getBlobInfoChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getDocumentChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getDocumentHighlightChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getDocumentMemberChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getSessionChanges_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 time.Time
	if tmp, ok := rawArgs["since"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("since"))
		arg0, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["since"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_id(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Account_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Account_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Account_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Account_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Account_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Account_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Account_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Account_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Account_name(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Account_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Account_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfo_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfo_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfo_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfoUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfoUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AccountInfo)
	fc.Result = res
	return ec.marshalNAccountInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfoUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccountInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_AccountInfo_name(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AccountInfo_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfoUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfoUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AccountInfo)
	fc.Result = res
	return ec.marshalNAccountInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfoUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccountInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_AccountInfo_name(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AccountInfo_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountInfoUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.AccountInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountInfoUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountInfoUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.AccountUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Account)
	fc.Result = res
	return ec.marshalNAccount2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Account_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Account_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Account_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.AccountUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Account)
	fc.Result = res
	return ec.marshalNAccount2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Account_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Account_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Account_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccountUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.AccountUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccountUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccountUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccountUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_hash(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_type(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_mimeType(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_mimeType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MimeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_mimeType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_size(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_source(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfo_local(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfo_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfo_local(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfoUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfoUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.BlobInfo)
	fc.Result = res
	return ec.marshalNBlobInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfoUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_BlobInfo_hash(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlobInfo_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_BlobInfo_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_BlobInfo_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_BlobInfo_type(ctx, field)
			case "mimeType":
				return ec.fieldContext_BlobInfo_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_BlobInfo_size(ctx, field)
			case "source":
				return ec.fieldContext_BlobInfo_source(ctx, field)
			case "local":
				return ec.fieldContext_BlobInfo_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlobInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfoUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfoUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.BlobInfo)
	fc.Result = res
	return ec.marshalNBlobInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfoUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_BlobInfo_hash(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlobInfo_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_BlobInfo_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_BlobInfo_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_BlobInfo_type(ctx, field)
			case "mimeType":
				return ec.fieldContext_BlobInfo_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_BlobInfo_size(ctx, field)
			case "source":
				return ec.fieldContext_BlobInfo_source(ctx, field)
			case "local":
				return ec.fieldContext_BlobInfo_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlobInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlobInfoUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.BlobInfoUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlobInfoUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlobInfoUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlobInfoUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_id(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_type(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_fileHash(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_fileHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_fileHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_meta(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_meta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Meta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOJSON2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_meta(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Document_local(ctx context.Context, field graphql.CollectedField, obj *model.Document) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Document_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Document_local(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Document",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_id(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_documentId(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_documentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_documentId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_documentType(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_documentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_documentType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_content(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_content(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOJSON2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_content(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_location(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOJSON2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_sequence(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_imageHash(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_imageHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_imageHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlight_local(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlight) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlight_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlight_local(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlight",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlightUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlightUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlightUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentHighlight)
	fc.Result = res
	return ec.marshalNDocumentHighlight2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlightUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlightUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentHighlight_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentHighlight_documentId(ctx, field)
			case "documentType":
				return ec.fieldContext_DocumentHighlight_documentType(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentHighlight_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentHighlight_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentHighlight_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentHighlight_createdBy(ctx, field)
			case "content":
				return ec.fieldContext_DocumentHighlight_content(ctx, field)
			case "location":
				return ec.fieldContext_DocumentHighlight_location(ctx, field)
			case "sequence":
				return ec.fieldContext_DocumentHighlight_sequence(ctx, field)
			case "imageHash":
				return ec.fieldContext_DocumentHighlight_imageHash(ctx, field)
			case "local":
				return ec.fieldContext_DocumentHighlight_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentHighlight", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlightUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlightUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlightUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentHighlight)
	fc.Result = res
	return ec.marshalNDocumentHighlight2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlightUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlightUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentHighlight_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentHighlight_documentId(ctx, field)
			case "documentType":
				return ec.fieldContext_DocumentHighlight_documentType(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentHighlight_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentHighlight_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentHighlight_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentHighlight_createdBy(ctx, field)
			case "content":
				return ec.fieldContext_DocumentHighlight_content(ctx, field)
			case "location":
				return ec.fieldContext_DocumentHighlight_location(ctx, field)
			case "sequence":
				return ec.fieldContext_DocumentHighlight_sequence(ctx, field)
			case "imageHash":
				return ec.fieldContext_DocumentHighlight_imageHash(ctx, field)
			case "local":
				return ec.fieldContext_DocumentHighlight_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentHighlight", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentHighlightUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.DocumentHighlightUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentHighlightUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentHighlightUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentHighlightUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_id(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_documentId(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_documentId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocumentID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_documentId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_accountId(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_accountId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_accountId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_acceptedAt(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_acceptedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_acceptedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_role(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uuid.UUID)
	fc.Result = res
	return ec.marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMember_local(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMember) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMember_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Local, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMember_local(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMemberUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMemberUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMemberUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentMember)
	fc.Result = res
	return ec.marshalNDocumentMember2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMemberUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMemberUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentMember_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentMember_documentId(ctx, field)
			case "accountId":
				return ec.fieldContext_DocumentMember_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentMember_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentMember_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentMember_deletedAt(ctx, field)
			case "acceptedAt":
				return ec.fieldContext_DocumentMember_acceptedAt(ctx, field)
			case "role":
				return ec.fieldContext_DocumentMember_role(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentMember_createdBy(ctx, field)
			case "local":
				return ec.fieldContext_DocumentMember_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMemberUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMemberUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMemberUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentMember)
	fc.Result = res
	return ec.marshalNDocumentMember2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMemberUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMemberUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentMember_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentMember_documentId(ctx, field)
			case "accountId":
				return ec.fieldContext_DocumentMember_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentMember_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentMember_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentMember_deletedAt(ctx, field)
			case "acceptedAt":
				return ec.fieldContext_DocumentMember_acceptedAt(ctx, field)
			case "role":
				return ec.fieldContext_DocumentMember_role(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentMember_createdBy(ctx, field)
			case "local":
				return ec.fieldContext_DocumentMember_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentMemberUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.DocumentMemberUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentMemberUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentMemberUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentMemberUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.DocumentUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Document)
	fc.Result = res
	return ec.marshalNDocument2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Document_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_Document_type(ctx, field)
			case "fileHash":
				return ec.fieldContext_Document_fileHash(ctx, field)
			case "meta":
				return ec.fieldContext_Document_meta(ctx, field)
			case "local":
				return ec.fieldContext_Document_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.DocumentUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Document)
	fc.Result = res
	return ec.marshalNDocument2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Document_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_Document_type(ctx, field)
			case "fileHash":
				return ec.fieldContext_Document_fileHash(ctx, field)
			case "meta":
				return ec.fieldContext_Document_meta(ctx, field)
			case "local":
				return ec.fieldContext_Document_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DocumentUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.DocumentUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DocumentUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DocumentUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DocumentUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushAccountChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushAccountChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushAccountChanges(rctx, fc.Args["input"].([]model.AccountInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AccountUpdateResult)
	fc.Result = res
	return ec.marshalNAccountUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushAccountChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_AccountUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_AccountUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_AccountUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushAccountChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushAccountInfoChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushAccountInfoChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushAccountInfoChanges(rctx, fc.Args["input"].([]model.AccountInfoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AccountInfoUpdateResult)
	fc.Result = res
	return ec.marshalNAccountInfoUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushAccountInfoChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_AccountInfoUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_AccountInfoUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_AccountInfoUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountInfoUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushAccountInfoChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushSessionChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushSessionChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushSessionChanges(rctx, fc.Args["input"].([]model.SessionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SessionUpdateResult)
	fc.Result = res
	return ec.marshalNSessionUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushSessionChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_SessionUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_SessionUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_SessionUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SessionUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushSessionChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushDocumentChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushDocumentChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushDocumentChanges(rctx, fc.Args["input"].([]model.DocumentInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DocumentUpdateResult)
	fc.Result = res
	return ec.marshalNDocumentUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushDocumentChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_DocumentUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_DocumentUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_DocumentUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushDocumentChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushDocumentMemberChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushDocumentMemberChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushDocumentMemberChanges(rctx, fc.Args["input"].([]model.DocumentMemberInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DocumentMemberUpdateResult)
	fc.Result = res
	return ec.marshalNDocumentMemberUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushDocumentMemberChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_DocumentMemberUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_DocumentMemberUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_DocumentMemberUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentMemberUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushDocumentMemberChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushDocumentHighlightChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushDocumentHighlightChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushDocumentHighlightChanges(rctx, fc.Args["input"].([]model.DocumentHighlightInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DocumentHighlightUpdateResult)
	fc.Result = res
	return ec.marshalNDocumentHighlightUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushDocumentHighlightChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_DocumentHighlightUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_DocumentHighlightUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_DocumentHighlightUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentHighlightUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushDocumentHighlightChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pushBlobInfoChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pushBlobInfoChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PushBlobInfoChanges(rctx, fc.Args["input"].([]model.BlobInfoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BlobInfoUpdateResult)
	fc.Result = res
	return ec.marshalNBlobInfoUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoUpdateResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pushBlobInfoChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "updated":
				return ec.fieldContext_BlobInfoUpdateResult_updated(ctx, field)
			case "rejected":
				return ec.fieldContext_BlobInfoUpdateResult_rejected(ctx, field)
			case "errors":
				return ec.fieldContext_BlobInfoUpdateResult_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlobInfoUpdateResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pushBlobInfoChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAccountChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAccountChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAccountChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Account)
	fc.Result = res
	return ec.marshalNAccount2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAccountChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Account_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Account_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Account_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAccountChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAccountInfoChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAccountInfoChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetAccountInfoChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AccountInfo)
	fc.Result = res
	return ec.marshalNAccountInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAccountInfoChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccountInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_AccountInfo_name(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AccountInfo_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAccountInfoChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getSessionChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getSessionChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSessionChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Session)
	fc.Result = res
	return ec.marshalNSession2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getSessionChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "accountId":
				return ec.fieldContext_Session_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Session_deletedAt(ctx, field)
			case "syncDocuments":
				return ec.fieldContext_Session_syncDocuments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getSessionChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDocumentChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDocumentChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDocumentChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Document)
	fc.Result = res
	return ec.marshalNDocument2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDocumentChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Document_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_Document_type(ctx, field)
			case "fileHash":
				return ec.fieldContext_Document_fileHash(ctx, field)
			case "meta":
				return ec.fieldContext_Document_meta(ctx, field)
			case "local":
				return ec.fieldContext_Document_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDocumentChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDocumentMemberChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDocumentMemberChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDocumentMemberChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentMember)
	fc.Result = res
	return ec.marshalNDocumentMember2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDocumentMemberChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentMember_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentMember_documentId(ctx, field)
			case "accountId":
				return ec.fieldContext_DocumentMember_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentMember_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentMember_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentMember_deletedAt(ctx, field)
			case "acceptedAt":
				return ec.fieldContext_DocumentMember_acceptedAt(ctx, field)
			case "role":
				return ec.fieldContext_DocumentMember_role(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentMember_createdBy(ctx, field)
			case "local":
				return ec.fieldContext_DocumentMember_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentMember", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDocumentMemberChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDocumentHighlightChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getDocumentHighlightChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDocumentHighlightChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.DocumentHighlight)
	fc.Result = res
	return ec.marshalNDocumentHighlight2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getDocumentHighlightChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentHighlight_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentHighlight_documentId(ctx, field)
			case "documentType":
				return ec.fieldContext_DocumentHighlight_documentType(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentHighlight_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentHighlight_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentHighlight_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentHighlight_createdBy(ctx, field)
			case "content":
				return ec.fieldContext_DocumentHighlight_content(ctx, field)
			case "location":
				return ec.fieldContext_DocumentHighlight_location(ctx, field)
			case "sequence":
				return ec.fieldContext_DocumentHighlight_sequence(ctx, field)
			case "imageHash":
				return ec.fieldContext_DocumentHighlight_imageHash(ctx, field)
			case "local":
				return ec.fieldContext_DocumentHighlight_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentHighlight", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDocumentHighlightChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBlobInfoChanges(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBlobInfoChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetBlobInfoChanges(rctx, fc.Args["since"].(time.Time), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.BlobInfo)
	fc.Result = res
	return ec.marshalNBlobInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBlobInfoChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_BlobInfo_hash(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlobInfo_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_BlobInfo_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_BlobInfo_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_BlobInfo_type(ctx, field)
			case "mimeType":
				return ec.fieldContext_BlobInfo_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_BlobInfo_size(ctx, field)
			case "source":
				return ec.fieldContext_BlobInfo_source(ctx, field)
			case "local":
				return ec.fieldContext_BlobInfo_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlobInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBlobInfoChanges_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_id(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_accountId(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_accountId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uuid.UUID)
	fc.Result = res
	return ec.marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_accountId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UUID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_deletedAt(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_deletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_deletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Session_syncDocuments(ctx context.Context, field graphql.CollectedField, obj *model.Session) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Session_syncDocuments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncDocuments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Session_syncDocuments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Session",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionUpdateResult_updated(ctx context.Context, field graphql.CollectedField, obj *model.SessionUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionUpdateResult_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Session)
	fc.Result = res
	return ec.marshalNSession2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionUpdateResult_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "accountId":
				return ec.fieldContext_Session_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Session_deletedAt(ctx, field)
			case "syncDocuments":
				return ec.fieldContext_Session_syncDocuments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionUpdateResult_rejected(ctx context.Context, field graphql.CollectedField, obj *model.SessionUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionUpdateResult_rejected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rejected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Session)
	fc.Result = res
	return ec.marshalNSession2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionUpdateResult_rejected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "accountId":
				return ec.fieldContext_Session_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Session_deletedAt(ctx, field)
			case "syncDocuments":
				return ec.fieldContext_Session_syncDocuments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SessionUpdateResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.SessionUpdateResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SessionUpdateResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.UpdateError)
	fc.Result = res
	return ec.marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SessionUpdateResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SessionUpdateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UpdateError_id(ctx, field)
			case "error":
				return ec.fieldContext_UpdateError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncAccountUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncAccountUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncAccountUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.Account):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAccount2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncAccountUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Account_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Account_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Account_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Account_deletedAt(ctx, field)
			case "name":
				return ec.fieldContext_Account_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Account", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncAccountInfoUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncAccountInfoUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncAccountInfoUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.AccountInfo):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAccountInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncAccountInfoUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccountInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_AccountInfo_name(ctx, field)
			case "updatedAt":
				return ec.fieldContext_AccountInfo_updatedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccountInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncSessionUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncSessionUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncSessionUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.Session):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNSession2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncSessionUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Session_id(ctx, field)
			case "accountId":
				return ec.fieldContext_Session_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_Session_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Session_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Session_deletedAt(ctx, field)
			case "syncDocuments":
				return ec.fieldContext_Session_syncDocuments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Session", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncDocumentUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncDocumentUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncDocumentUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.Document):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNDocument2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncDocumentUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Document_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Document_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Document_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_Document_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_Document_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_Document_type(ctx, field)
			case "fileHash":
				return ec.fieldContext_Document_fileHash(ctx, field)
			case "meta":
				return ec.fieldContext_Document_meta(ctx, field)
			case "local":
				return ec.fieldContext_Document_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Document", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncDocumentMemberUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncDocumentMemberUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncDocumentMemberUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.DocumentMember):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNDocumentMember2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncDocumentMemberUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentMember_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentMember_documentId(ctx, field)
			case "accountId":
				return ec.fieldContext_DocumentMember_accountId(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentMember_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentMember_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentMember_deletedAt(ctx, field)
			case "acceptedAt":
				return ec.fieldContext_DocumentMember_acceptedAt(ctx, field)
			case "role":
				return ec.fieldContext_DocumentMember_role(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentMember_createdBy(ctx, field)
			case "local":
				return ec.fieldContext_DocumentMember_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncDocumentHighlightUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncDocumentHighlightUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncDocumentHighlightUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.DocumentHighlight):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNDocumentHighlight2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncDocumentHighlightUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DocumentHighlight_id(ctx, field)
			case "documentId":
				return ec.fieldContext_DocumentHighlight_documentId(ctx, field)
			case "documentType":
				return ec.fieldContext_DocumentHighlight_documentType(ctx, field)
			case "createdAt":
				return ec.fieldContext_DocumentHighlight_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_DocumentHighlight_updatedAt(ctx, field)
			case "deletedAt":
				return ec.fieldContext_DocumentHighlight_deletedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_DocumentHighlight_createdBy(ctx, field)
			case "content":
				return ec.fieldContext_DocumentHighlight_content(ctx, field)
			case "location":
				return ec.fieldContext_DocumentHighlight_location(ctx, field)
			case "sequence":
				return ec.fieldContext_DocumentHighlight_sequence(ctx, field)
			case "imageHash":
				return ec.fieldContext_DocumentHighlight_imageHash(ctx, field)
			case "local":
				return ec.fieldContext_DocumentHighlight_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DocumentHighlight", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_syncBlobInfoUpdates(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_syncBlobInfoUpdates(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().SyncBlobInfoUpdates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan []model.BlobInfo):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBlobInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoᚄ(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_syncBlobInfoUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_BlobInfo_hash(ctx, field)
			case "createdAt":
				return ec.fieldContext_BlobInfo_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_BlobInfo_updatedAt(ctx, field)
			case "createdBy":
				return ec.fieldContext_BlobInfo_createdBy(ctx, field)
			case "type":
				return ec.fieldContext_BlobInfo_type(ctx, field)
			case "mimeType":
				return ec.fieldContext_BlobInfo_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_BlobInfo_size(ctx, field)
			case "source":
				return ec.fieldContext_BlobInfo_source(ctx, field)
			case "local":
				return ec.fieldContext_BlobInfo_local(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlobInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateError_id(ctx context.Context, field graphql.CollectedField, obj *model.UpdateError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateError_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateError_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateError_error(ctx context.Context, field graphql.CollectedField, obj *model.UpdateError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateError_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateError_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccountInfoInput(ctx context.Context, obj interface{}) (model.AccountInfoInput, error) {
	var it model.AccountInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "updatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAccountInput(ctx context.Context, obj interface{}) (model.AccountInput, error) {
	var it model.AccountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "createdAt", "updatedAt", "deletedAt", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "deletedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			it.DeletedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlobInfoInput(ctx context.Context, obj interface{}) (model.BlobInfoInput, error) {
	var it model.BlobInfoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hash", "createdAt", "updatedAt", "createdBy", "type", "mimeType", "size", "source", "local"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			it.Hash, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			it.CreatedBy, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "mimeType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mimeType"))
			it.MimeType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			it.Size, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			it.Source, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "local":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("local"))
			it.Local, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocumentHighlightInput(ctx context.Context, obj interface{}) (model.DocumentHighlightInput, error) {
	var it model.DocumentHighlightInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "documentId", "documentType", "createdAt", "updatedAt", "deletedAt", "createdBy", "content", "location", "sequence", "imageHash", "local"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "documentId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("documentId"))
			it.DocumentID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "documentType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("documentType"))
			it.DocumentType, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "deletedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			it.DeletedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			it.CreatedBy, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "content":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			it.Content, err = ec.unmarshalOJSON2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "location":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			it.Location, err = ec.unmarshalOJSON2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "sequence":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sequence"))
			it.Sequence, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "imageHash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageHash"))
			it.ImageHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "local":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("local"))
			it.Local, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocumentInput(ctx context.Context, obj interface{}) (model.DocumentInput, error) {
	var it model.DocumentInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "createdAt", "updatedAt", "deletedAt", "createdBy", "type", "fileHash", "meta", "local"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "deletedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			it.DeletedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			it.CreatedBy, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "fileHash":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileHash"))
			it.FileHash, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "meta":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("meta"))
			it.Meta, err = ec.unmarshalOJSON2interface(ctx, v)
			if err != nil {
				return it, err
			}
		case "local":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("local"))
			it.Local, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocumentMemberInput(ctx context.Context, obj interface{}) (model.DocumentMemberInput, error) {
	var it model.DocumentMemberInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "documentId", "accountId", "createdAt", "updatedAt", "deletedAt", "acceptedAt", "role", "createdBy", "local"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "documentId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("documentId"))
			it.DocumentID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
			it.AccountID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "deletedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			it.DeletedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "acceptedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptedAt"))
			it.AcceptedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			it.Role, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBy"))
			it.CreatedBy, err = ec.unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "local":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("local"))
			it.Local, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSessionInput(ctx context.Context, obj interface{}) (model.SessionInput, error) {
	var it model.SessionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "accountId", "createdAt", "updatedAt", "deletedAt", "syncDocuments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "accountId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
			it.AccountID, err = ec.unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
		case "createdAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			it.CreatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "updatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			it.UpdatedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "deletedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedAt"))
			it.DeletedAt, err = ec.unmarshalODateTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "syncDocuments":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("syncDocuments"))
			it.SyncDocuments, err = ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *model.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "id":

			out.Values[i] = ec._Account_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Account_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._Account_updatedAt(ctx, field, obj)

		case "deletedAt":

			out.Values[i] = ec._Account_deletedAt(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Account_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountInfoImplementors = []string{"AccountInfo"}

func (ec *executionContext) _AccountInfo(ctx context.Context, sel ast.SelectionSet, obj *model.AccountInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountInfo")
		case "id":

			out.Values[i] = ec._AccountInfo_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._AccountInfo_name(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._AccountInfo_updatedAt(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountInfoUpdateResultImplementors = []string{"AccountInfoUpdateResult"}

func (ec *executionContext) _AccountInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.AccountInfoUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountInfoUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountInfoUpdateResult")
		case "updated":

			out.Values[i] = ec._AccountInfoUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._AccountInfoUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._AccountInfoUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountUpdateResultImplementors = []string{"AccountUpdateResult"}

func (ec *executionContext) _AccountUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.AccountUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountUpdateResult")
		case "updated":

			out.Values[i] = ec._AccountUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._AccountUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._AccountUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blobInfoImplementors = []string{"BlobInfo"}

func (ec *executionContext) _BlobInfo(ctx context.Context, sel ast.SelectionSet, obj *model.BlobInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blobInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlobInfo")
		case "hash":

			out.Values[i] = ec._BlobInfo_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._BlobInfo_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._BlobInfo_updatedAt(ctx, field, obj)

		case "createdBy":

			out.Values[i] = ec._BlobInfo_createdBy(ctx, field, obj)

		case "type":

			out.Values[i] = ec._BlobInfo_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mimeType":

			out.Values[i] = ec._BlobInfo_mimeType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "size":

			out.Values[i] = ec._BlobInfo_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "source":

			out.Values[i] = ec._BlobInfo_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "local":

			out.Values[i] = ec._BlobInfo_local(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blobInfoUpdateResultImplementors = []string{"BlobInfoUpdateResult"}

func (ec *executionContext) _BlobInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.BlobInfoUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blobInfoUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlobInfoUpdateResult")
		case "updated":

			out.Values[i] = ec._BlobInfoUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._BlobInfoUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._BlobInfoUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentImplementors = []string{"Document"}

func (ec *executionContext) _Document(ctx context.Context, sel ast.SelectionSet, obj *model.Document) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Document")
		case "id":

			out.Values[i] = ec._Document_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Document_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._Document_updatedAt(ctx, field, obj)

		case "deletedAt":

			out.Values[i] = ec._Document_deletedAt(ctx, field, obj)

		case "createdBy":

			out.Values[i] = ec._Document_createdBy(ctx, field, obj)

		case "type":

			out.Values[i] = ec._Document_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fileHash":

			out.Values[i] = ec._Document_fileHash(ctx, field, obj)

		case "meta":

			out.Values[i] = ec._Document_meta(ctx, field, obj)

		case "local":

			out.Values[i] = ec._Document_local(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentHighlightImplementors = []string{"DocumentHighlight"}

func (ec *executionContext) _DocumentHighlight(ctx context.Context, sel ast.SelectionSet, obj *model.DocumentHighlight) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentHighlightImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentHighlight")
		case "id":

			out.Values[i] = ec._DocumentHighlight_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentId":

			out.Values[i] = ec._DocumentHighlight_documentId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "documentType":

			out.Values[i] = ec._DocumentHighlight_documentType(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._DocumentHighlight_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._DocumentHighlight_updatedAt(ctx, field, obj)

		case "deletedAt":

			out.Values[i] = ec._DocumentHighlight_deletedAt(ctx, field, obj)

		case "createdBy":

			out.Values[i] = ec._DocumentHighlight_createdBy(ctx, field, obj)

		case "content":

			out.Values[i] = ec._DocumentHighlight_content(ctx, field, obj)

		case "location":

			out.Values[i] = ec._DocumentHighlight_location(ctx, field, obj)

		case "sequence":

			out.Values[i] = ec._DocumentHighlight_sequence(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "imageHash":

			out.Values[i] = ec._DocumentHighlight_imageHash(ctx, field, obj)

		case "local":

			out.Values[i] = ec._DocumentHighlight_local(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentHighlightUpdateResultImplementors = []string{"DocumentHighlightUpdateResult"}

func (ec *executionContext) _DocumentHighlightUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.DocumentHighlightUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentHighlightUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentHighlightUpdateResult")
		case "updated":

			out.Values[i] = ec._DocumentHighlightUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._DocumentHighlightUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._DocumentHighlightUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentMemberImplementors = []string{"DocumentMember"}

func (ec *executionContext) _DocumentMember(ctx context.Context, sel ast.SelectionSet, obj *model.DocumentMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentMemberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentMember")
		case "id":

			out.Values[i] = ec._DocumentMember_id(ctx, field, obj)

		case "documentId":

			out.Values[i] = ec._DocumentMember_documentId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accountId":

			out.Values[i] = ec._DocumentMember_accountId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._DocumentMember_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._DocumentMember_updatedAt(ctx, field, obj)

		case "deletedAt":

			out.Values[i] = ec._DocumentMember_deletedAt(ctx, field, obj)

		case "acceptedAt":

			out.Values[i] = ec._DocumentMember_acceptedAt(ctx, field, obj)

		case "role":

			out.Values[i] = ec._DocumentMember_role(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdBy":

			out.Values[i] = ec._DocumentMember_createdBy(ctx, field, obj)

		case "local":

			out.Values[i] = ec._DocumentMember_local(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentMemberUpdateResultImplementors = []string{"DocumentMemberUpdateResult"}

func (ec *executionContext) _DocumentMemberUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.DocumentMemberUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentMemberUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentMemberUpdateResult")
		case "updated":

			out.Values[i] = ec._DocumentMemberUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._DocumentMemberUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._DocumentMemberUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var documentUpdateResultImplementors = []string{"DocumentUpdateResult"}

func (ec *executionContext) _DocumentUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.DocumentUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, documentUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DocumentUpdateResult")
		case "updated":

			out.Values[i] = ec._DocumentUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._DocumentUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._DocumentUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "pushAccountChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushAccountChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushAccountInfoChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushAccountInfoChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushSessionChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushSessionChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushDocumentChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushDocumentChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushDocumentMemberChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushDocumentMemberChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushDocumentHighlightChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushDocumentHighlightChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pushBlobInfoChanges":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pushBlobInfoChanges(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getAccountChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAccountChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAccountInfoChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAccountInfoChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getSessionChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSessionChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getDocumentChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDocumentChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getDocumentMemberChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDocumentMemberChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getDocumentHighlightChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDocumentHighlightChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBlobInfoChanges":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBlobInfoChanges(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sessionImplementors = []string{"Session"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *model.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "id":

			out.Values[i] = ec._Session_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accountId":

			out.Values[i] = ec._Session_accountId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createdAt":

			out.Values[i] = ec._Session_createdAt(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._Session_updatedAt(ctx, field, obj)

		case "deletedAt":

			out.Values[i] = ec._Session_deletedAt(ctx, field, obj)

		case "syncDocuments":

			out.Values[i] = ec._Session_syncDocuments(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sessionUpdateResultImplementors = []string{"SessionUpdateResult"}

func (ec *executionContext) _SessionUpdateResult(ctx context.Context, sel ast.SelectionSet, obj *model.SessionUpdateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sessionUpdateResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SessionUpdateResult")
		case "updated":

			out.Values[i] = ec._SessionUpdateResult_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rejected":

			out.Values[i] = ec._SessionUpdateResult_rejected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._SessionUpdateResult_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "syncAccountUpdates":
		return ec._Subscription_syncAccountUpdates(ctx, fields[0])
	case "syncAccountInfoUpdates":
		return ec._Subscription_syncAccountInfoUpdates(ctx, fields[0])
	case "syncSessionUpdates":
		return ec._Subscription_syncSessionUpdates(ctx, fields[0])
	case "syncDocumentUpdates":
		return ec._Subscription_syncDocumentUpdates(ctx, fields[0])
	case "syncDocumentMemberUpdates":
		return ec._Subscription_syncDocumentMemberUpdates(ctx, fields[0])
	case "syncDocumentHighlightUpdates":
		return ec._Subscription_syncDocumentHighlightUpdates(ctx, fields[0])
	case "syncBlobInfoUpdates":
		return ec._Subscription_syncBlobInfoUpdates(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var updateErrorImplementors = []string{"UpdateError"}

func (ec *executionContext) _UpdateError(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateErrorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateError")
		case "id":

			out.Values[i] = ec._UpdateError_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "error":

			out.Values[i] = ec._UpdateError_error(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccount2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccount(ctx context.Context, sel ast.SelectionSet, v model.Account) graphql.Marshaler {
	return ec._Account(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccount2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Account) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccount2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAccountInfo2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfo(ctx context.Context, sel ast.SelectionSet, v model.AccountInfo) graphql.Marshaler {
	return ec._AccountInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccountInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoᚄ(ctx context.Context, sel ast.SelectionSet, v []model.AccountInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccountInfo2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAccountInfoInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoInput(ctx context.Context, v interface{}) (model.AccountInfoInput, error) {
	res, err := ec.unmarshalInputAccountInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAccountInfoInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoInputᚄ(ctx context.Context, v interface{}) ([]model.AccountInfoInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.AccountInfoInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountInfoInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNAccountInfoUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.AccountInfoUpdateResult) graphql.Marshaler {
	return ec._AccountInfoUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccountInfoUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.AccountInfoUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccountInfoUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAccountInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInput(ctx context.Context, v interface{}) (model.AccountInput, error) {
	res, err := ec.unmarshalInputAccountInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAccountInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInputᚄ(ctx context.Context, v interface{}) ([]model.AccountInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.AccountInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccountInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNAccountUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.AccountUpdateResult) graphql.Marshaler {
	return ec._AccountUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccountUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐAccountUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.AccountUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccountUpdateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNBlobInfo2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfo(ctx context.Context, sel ast.SelectionSet, v model.BlobInfo) graphql.Marshaler {
	return ec._BlobInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlobInfo2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoᚄ(ctx context.Context, sel ast.SelectionSet, v []model.BlobInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlobInfo2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNBlobInfoInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoInput(ctx context.Context, v interface{}) (model.BlobInfoInput, error) {
	res, err := ec.unmarshalInputBlobInfoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBlobInfoInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoInputᚄ(ctx context.Context, v interface{}) ([]model.BlobInfoInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.BlobInfoInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlobInfoInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNBlobInfoUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.BlobInfoUpdateResult) graphql.Marshaler {
	return ec._BlobInfoUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlobInfoUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐBlobInfoUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.BlobInfoUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BlobInfoUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNDocument2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocument(ctx context.Context, sel ast.SelectionSet, v model.Document) graphql.Marshaler {
	return ec._Document(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocument2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Document) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDocument2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocument(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDocumentHighlight2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlight(ctx context.Context, sel ast.SelectionSet, v model.DocumentHighlight) graphql.Marshaler {
	return ec._DocumentHighlight(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocumentHighlight2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightᚄ(ctx context.Context, sel ast.SelectionSet, v []model.DocumentHighlight) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDocumentHighlight2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlight(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDocumentHighlightInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightInput(ctx context.Context, v interface{}) (model.DocumentHighlightInput, error) {
	res, err := ec.unmarshalInputDocumentHighlightInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocumentHighlightInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightInputᚄ(ctx context.Context, v interface{}) ([]model.DocumentHighlightInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.DocumentHighlightInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocumentHighlightInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDocumentHighlightUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.DocumentHighlightUpdateResult) graphql.Marshaler {
	return ec._DocumentHighlightUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocumentHighlightUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentHighlightUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.DocumentHighlightUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DocumentHighlightUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDocumentInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentInput(ctx context.Context, v interface{}) (model.DocumentInput, error) {
	res, err := ec.unmarshalInputDocumentInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocumentInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentInputᚄ(ctx context.Context, v interface{}) ([]model.DocumentInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.DocumentInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocumentInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDocumentMember2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMember(ctx context.Context, sel ast.SelectionSet, v model.DocumentMember) graphql.Marshaler {
	return ec._DocumentMember(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocumentMember2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberᚄ(ctx context.Context, sel ast.SelectionSet, v []model.DocumentMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDocumentMember2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDocumentMemberInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberInput(ctx context.Context, v interface{}) (model.DocumentMemberInput, error) {
	res, err := ec.unmarshalInputDocumentMemberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocumentMemberInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberInputᚄ(ctx context.Context, v interface{}) ([]model.DocumentMemberInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.DocumentMemberInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocumentMemberInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDocumentMemberUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.DocumentMemberUpdateResult) graphql.Marshaler {
	return ec._DocumentMemberUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocumentMemberUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentMemberUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.DocumentMemberUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DocumentMemberUpdateResult(ctx, sel, v)
}

func (ec *executionContext) marshalNDocumentUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.DocumentUpdateResult) graphql.Marshaler {
	return ec._DocumentUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocumentUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐDocumentUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.DocumentUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DocumentUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSession2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSession(ctx context.Context, sel ast.SelectionSet, v model.Session) graphql.Marshaler {
	return ec._Session(ctx, sel, &v)
}

func (ec *executionContext) marshalNSession2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Session) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSession2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSession(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSessionInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionInput(ctx context.Context, v interface{}) (model.SessionInput, error) {
	res, err := ec.unmarshalInputSessionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSessionInput2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionInputᚄ(ctx context.Context, v interface{}) ([]model.SessionInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.SessionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSessionInput2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNSessionUpdateResult2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionUpdateResult(ctx context.Context, sel ast.SelectionSet, v model.SessionUpdateResult) graphql.Marshaler {
	return ec._SessionUpdateResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNSessionUpdateResult2ᚖgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐSessionUpdateResult(ctx context.Context, sel ast.SelectionSet, v *model.SessionUpdateResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SessionUpdateResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v interface{}) (uuid.UUID, error) {
	res, err := util.UnmarshalUUID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUUID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	res := util.MarshalUUID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUpdateError2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateError(ctx context.Context, sel ast.SelectionSet, v model.UpdateError) graphql.Marshaler {
	return ec._UpdateError(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODateTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOJSON2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJSON2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v interface{}) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := util.UnmarshalUUID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUUID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := util.MarshalUUID(*v)
	return res
}

func (ec *executionContext) marshalOUpdateError2ᚕgithubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateErrorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.UpdateError) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUpdateError2githubᚗcomᚋxtruderᚋpdfᚑclipperᚋpackagesᚋserverᚑgoᚋgraphᚋmodelᚐUpdateError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
