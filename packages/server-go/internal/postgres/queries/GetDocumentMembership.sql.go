// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype/zeronull"
	"github.com/jackc/pgx/v4"
)

const getDocumentsMembershipSQL = `SELECT
  document_id,
  role
FROM public.document_members
WHERE
  account_id = $1 AND
  accepted_at > '0001-01-01 00:00:00+00'  AND
  deleted_at <= '0001-01-01 00:00:00+00' AND

  -- make sure document is not deleted
  EXISTS (
    SELECT 1 FROM public.documents
      WHERE id = document_id AND deleted_at <= '0001-01-01 00:00:00+00'
  );`

type GetDocumentsMembershipRow struct {
	DocumentID zeronull.UUID `json:"document_id"`
	Role       DocumentRole  `json:"role"`
}

// GetDocumentsMembership implements Querier.GetDocumentsMembership.
func (q *DBQuerier) GetDocumentsMembership(ctx context.Context, accountID zeronull.UUID) ([]GetDocumentsMembershipRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetDocumentsMembership")
	rows, err := q.conn.Query(ctx, getDocumentsMembershipSQL, accountID)
	if err != nil {
		return nil, fmt.Errorf("query GetDocumentsMembership: %w", err)
	}
	defer rows.Close()
	items := []GetDocumentsMembershipRow{}
	for rows.Next() {
		var item GetDocumentsMembershipRow
		if err := rows.Scan(&item.DocumentID, &item.Role); err != nil {
			return nil, fmt.Errorf("scan GetDocumentsMembership row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetDocumentsMembership rows: %w", err)
	}
	return items, err
}

// GetDocumentsMembershipBatch implements Querier.GetDocumentsMembershipBatch.
func (q *DBQuerier) GetDocumentsMembershipBatch(batch genericBatch, accountID zeronull.UUID) {
	batch.Queue(getDocumentsMembershipSQL, accountID)
}

// GetDocumentsMembershipScan implements Querier.GetDocumentsMembershipScan.
func (q *DBQuerier) GetDocumentsMembershipScan(results pgx.BatchResults) ([]GetDocumentsMembershipRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query GetDocumentsMembershipBatch: %w", err)
	}
	defer rows.Close()
	items := []GetDocumentsMembershipRow{}
	for rows.Next() {
		var item GetDocumentsMembershipRow
		if err := rows.Scan(&item.DocumentID, &item.Role); err != nil {
			return nil, fmt.Errorf("scan GetDocumentsMembershipBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetDocumentsMembershipBatch rows: %w", err)
	}
	return items, err
}
