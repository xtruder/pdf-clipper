// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype/zeronull"
	"github.com/jackc/pgx/v4"
)

const getBlobInfoUpdatesForDocumentSQL = `SELECT
  blob_infos.hash,
  blob_infos.type,
  blob_infos.created_at,
  blob_infos.updated_at,
  blob_infos.created_by,
  blob_infos.mime_type,
  blob_infos.size,
  blob_infos.source
FROM public.blob_infos
WHERE
  blob_infos.updated_at > $1 AND
  (
    blob_infos.hash IN (SELECT documents.file_hash FROM public.documents WHERE id = $2) OR
    blob_infos.hash IN (SELECT document_highlights.image_hash FROM public.document_highlights WHERE document_id = $2)
  );`

type GetBlobInfoUpdatesForDocumentRow struct {
	Hash      zeronull.Text        `json:"hash"`
	Type      BlobType             `json:"type"`
	CreatedAt zeronull.Timestamptz `json:"created_at"`
	UpdatedAt zeronull.Timestamptz `json:"updated_at"`
	CreatedBy zeronull.UUID        `json:"created_by"`
	MimeType  zeronull.Text        `json:"mime_type"`
	Size      int32                `json:"size"`
	Source    zeronull.Text        `json:"source"`
}

// GetBlobInfoUpdatesForDocument implements Querier.GetBlobInfoUpdatesForDocument.
func (q *DBQuerier) GetBlobInfoUpdatesForDocument(ctx context.Context, since zeronull.Timestamptz, documentID zeronull.UUID) ([]GetBlobInfoUpdatesForDocumentRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetBlobInfoUpdatesForDocument")
	rows, err := q.conn.Query(ctx, getBlobInfoUpdatesForDocumentSQL, since, documentID)
	if err != nil {
		return nil, fmt.Errorf("query GetBlobInfoUpdatesForDocument: %w", err)
	}
	defer rows.Close()
	items := []GetBlobInfoUpdatesForDocumentRow{}
	for rows.Next() {
		var item GetBlobInfoUpdatesForDocumentRow
		if err := rows.Scan(&item.Hash, &item.Type, &item.CreatedAt, &item.UpdatedAt, &item.CreatedBy, &item.MimeType, &item.Size, &item.Source); err != nil {
			return nil, fmt.Errorf("scan GetBlobInfoUpdatesForDocument row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetBlobInfoUpdatesForDocument rows: %w", err)
	}
	return items, err
}

// GetBlobInfoUpdatesForDocumentBatch implements Querier.GetBlobInfoUpdatesForDocumentBatch.
func (q *DBQuerier) GetBlobInfoUpdatesForDocumentBatch(batch genericBatch, since zeronull.Timestamptz, documentID zeronull.UUID) {
	batch.Queue(getBlobInfoUpdatesForDocumentSQL, since, documentID)
}

// GetBlobInfoUpdatesForDocumentScan implements Querier.GetBlobInfoUpdatesForDocumentScan.
func (q *DBQuerier) GetBlobInfoUpdatesForDocumentScan(results pgx.BatchResults) ([]GetBlobInfoUpdatesForDocumentRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query GetBlobInfoUpdatesForDocumentBatch: %w", err)
	}
	defer rows.Close()
	items := []GetBlobInfoUpdatesForDocumentRow{}
	for rows.Next() {
		var item GetBlobInfoUpdatesForDocumentRow
		if err := rows.Scan(&item.Hash, &item.Type, &item.CreatedAt, &item.UpdatedAt, &item.CreatedBy, &item.MimeType, &item.Size, &item.Source); err != nil {
			return nil, fmt.Errorf("scan GetBlobInfoUpdatesForDocumentBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close GetBlobInfoUpdatesForDocumentBatch rows: %w", err)
	}
	return items, err
}
